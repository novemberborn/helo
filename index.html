<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>helo - README.md</title>

  <link rel="stylesheet" href="assets/style.css">

  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"/>
  <meta name="groc-relative-root" content=""/>
  <meta name="groc-document-path" content="README.md"/>
  
</head>
<body>
  <div id="file-area">
    <div id="meta">
      <code class="file-path">
      
        <a href="https://github.com/novemberborn/helo/blob/master/README.md">README.md</a>
      
      </code>
    </div>
    <div id="document">
    
      <div class="segment">
      
        <div class="comments ">
          <div class="wrapper"><h1 id="helo"><a href="#helo" class="anchor"></a>helo</h1><p>Promise-based HTTP request handling stack.</p>
<h2 id="deprecation-notice"><a href="#deprecation-notice" class="anchor"></a>Deprecation Notice</h2><p>This module is no longer maintained. It still has some neat ideas though.</p>
<h2 id="installation"><a href="#installation" class="anchor"></a>Installation</h2><pre><code>npm <span class="hljs-keyword">install</span> legendary
npm <span class="hljs-keyword">install</span> helo
</code></pre><p>This module has a peer dependency on
<a href="https://github.com/novemberborn/legendary">Legendary</a>.</p>
<h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>See <a href="http://novemberborn.github.io/helo/lib/main.js.html">API Docs</a>.</p>
<h3 id="request-handling"><a href="#request-handling" class="anchor"></a>Request handling</h3><p>Helo handles requests a little differently than a standard Node HTTP server. To
see how, let&#39;s start with a standard example:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span><span class="hljs-params">(req, res)</span> {</span>
  setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    res.writeHead(<span class="hljs-number">200</span>, { <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'text/html'</span> });
    res.end(<span class="hljs-string">'&lt;p&gt;Hello world&lt;/p&gt;'</span>);
  }, <span class="hljs-number">2000</span>);
}

<span class="hljs-keyword">var</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).createServer(app);
server.listen(<span class="hljs-number">8080</span>);
</code></pre>
<p>The application receives a <code>req</code> argument, the <em>incoming message</em>, and a
<code>res</code> argument, the <em>outgoing message</em>. It writes directly to the outgoing
message.</p>
<p>Here&#39;s Helo&#39;s equivalent:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> delay = <span class="hljs-built_in">require</span>(<span class="hljs-string">'legendary'</span>).timed.delay;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span><span class="hljs-params">(request)</span> {</span>
  <span class="hljs-keyword">return</span> delay(<span class="hljs-number">2000</span>).yield({
    statusCode: <span class="hljs-number">200</span>,
    html: <span class="hljs-string">'&lt;p&gt;Hello world&lt;/p&gt;'</span>
  });
}

<span class="hljs-keyword">var</span> server = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>).createServer();

<span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack()
  .finalize(app)
  .observe(server);

server.listen(<span class="hljs-number">8080</span>);
</code></pre>
<h4 id="responses"><a href="#responses" class="anchor"></a>Responses</h4><p>The application does not receive the outgoing message, instead it&#39;s expected to
return a (promise for a) response object. This is then written to the outgoing
message by Helo. <a href="http://novemberborn.github.io/helo/doc/Responses.md.html">Read more about the response
objects</a>.</p>
<p>The promise is cancelled if the outgoing message is closed before the promise
has fulfilled. This allows the application to decide whether to continue
handling the request even though its response will never reach the end-user.</p>
<h4 id="requests"><a href="#requests" class="anchor"></a>Requests</h4><p>The request received by the application is a wrapper for the incoming message.
<a href="http://novemberborn.github.io/helo/doc/Requests.md.html">Read more about the default request
properties</a>.</p>
<p>Each stack has its own <code>Request</code> class. You can extend its prototype:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> stack = <span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack();
stack.Request.prototype.metasyntactic = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
  <span class="hljs-keyword">return</span> <span class="hljs-string">'foo'</span>;
};
</code></pre>
<p>To add specific properties to the request, as it&#39;s instantiated, you can use
<a href="http://novemberborn.github.io/helo/lib/Stack.js.html#stack-addrequestinitializer-initializer-"><code>Stack#addRequestInitializer()</code></a>:</p>
<pre><code class="lang-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack()
  .addRequestInitializer(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
    <span class="hljs-keyword">this</span>.start = <span class="hljs-keyword">this</span>.headers[<span class="hljs-string">'x-request-start'</span>];
  })
  .finalize(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request)</span> {</span>
    <span class="hljs-keyword">return</span> {
      statusCode: <span class="hljs-number">200</span>,
      html: [<span class="hljs-string">'&lt;p&gt;Received request at '</span>, request.start, <span class="hljs-string">'&lt;/p&gt;'</span>]
    };
  });
</code></pre>
<h4 id="middleware"><a href="#middleware" class="anchor"></a>Middleware</h4><p><a href="http://novemberborn.github.io/helo/lib/Stack.js.html#stack-addmiddleware-factory-"><code>Stack#addMiddleware()</code></a>
can be used to set up a chain of functions that&#39;ll be invoked before the
request is passed to the application:</p>
<pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">app</span><span class="hljs-params">(request)</span> {</span>
  <span class="hljs-keyword">return</span> {
    statusCode: <span class="hljs-number">200</span>,
    html: <span class="hljs-string">'&lt;p&gt;Hello world&lt;/p&gt;'</span>
  };
}

<span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack()
  .addMiddleware(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request)</span> {</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">1</span>/<span class="hljs-number">3</span>) {
        <span class="hljs-keyword">return</span> {
          statusCode: <span class="hljs-number">200</span>,
          html: <span class="hljs-string">'&lt;p&gt;Intercepted request before application was reached.&lt;/p&gt;'</span>
        };
      }

      <span class="hljs-keyword">return</span> next(request);
    };
  })
  .addMiddleware(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span> {</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(request)</span> {</span>
      <span class="hljs-keyword">return</span> next(request).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span> {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">1</span>/<span class="hljs-number">3</span>) {
          <span class="hljs-keyword">return</span> {
            statusCode: <span class="hljs-number">200</span>,
            html: <span class="hljs-string">'&lt;p&gt;Replaced application response.&lt;/p&gt;'</span>
          };
        }

        <span class="hljs-keyword">return</span> response;
      });
    };
  })
  .finalize(app);
</code></pre>
<p><code>next</code> will invoke the next middleware function or indeed the application. It
always returns a promise, albeit rejected if the function throws.</p>
<p>Middleware should <em>not</em> be used to set properties on the <code>request</code>. Use
request initializers instead.</p>
<h4 id="plugins"><a href="#plugins" class="anchor"></a>Plugins</h4><p>Plugins combine request initializers and middleware in a single object:</p>
<pre><code class="lang-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack()
  .install({
    requestInitializer: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>},
    middleware: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(next)</span> {</span>
      <span class="hljs-keyword">return</span> next;
    }
  });
</code></pre>
<h4 id="low-level-error-responses"><a href="#low-level-error-responses" class="anchor"></a>Low-level error responses</h4><p>A <code>503</code> response is generated when the response promise is rejected with an
error that has a <code>cancel</code> as its <code>name</code>. Similarly if the error has <code>timeout</code> as
its <code>name</code>, a <code>504</code> response is generated. For all other errors a <code>500</code> response
is used.</p>
<p>Normally these responses do not have headers or indeed a response body, but they
can be customized:</p>
<pre><code class="lang-js"><span class="hljs-built_in">require</span>(<span class="hljs-string">'helo'</span>).Stack()
  .setErrorResponse({
    statusCode: <span class="hljs-number">500</span>,
    headers: { <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'text/html'</span> },
    chunk: <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'&lt;p&gt;An internal error occurred.&lt;/p&gt;'</span>)
  })
  .setErrorResponse({
    statusCode: <span class="hljs-number">503</span>,
    headers: { <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'text/html'</span> },
    chunk: <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'&lt;p&gt;Service unavailable.&lt;/p&gt;'</span>)
  })
  .setErrorResponse({
    statusCode: <span class="hljs-number">504</span>,
    headers: { <span class="hljs-string">'content-type'</span>: <span class="hljs-string">'text/html'</span> },
    chunk: <span class="hljs-keyword">new</span> Buffer(<span class="hljs-string">'&lt;p&gt;Service timed out.&lt;/p&gt;'</span>)
  });
</code></pre>
<h4 id="lifecycle-events"><a href="#lifecycle-events" class="anchor"></a>Lifecycle events</h4><p>Events are emitted from the stack when new requests are made, errors occur, or
responses are written. <a href="http://novemberborn.github.io/helo/doc/Events.md.html">Read more about
events</a>.</p>
<h4 id="and-more-"><a href="#and-more-" class="anchor"></a>And more!</h4><p>See <a href="http://novemberborn.github.io/helo/lib/main.js.html">API Docs</a>.</p>
</div>
        </div>
      
      
      </div>
    
    </div>
  </div>

  <script src="toc.js"></script>
  <script src="assets/libs.js"></script>
  <script src="assets/behavior.js"></script>
</body>
</html>